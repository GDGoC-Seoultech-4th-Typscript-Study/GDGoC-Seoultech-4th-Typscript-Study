### 타입과 인터페이스

1. 공통점

- 명명된 타입(named type)을 정의하는 방법
- 인덱스 시그니처 사용 가능
  > **인덱스 시그니처?**  
  > 객체가 <key, value> 형식이고 각 타입을 정확하게 명시해야 하는 경우 사용 가능  
  > _참고: [velog - [TypeScript] 인덱스 시그니처](https://velog.io/@ahsy92/TypeScript-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98)_
- 함수 타입 정의 가능
- 제너릭(Generic) 가능
- 타입은 인터페이스 확장 가능, 인터페이스는 타입 확장 가능
- 클래스 구현 시 사용 가능

2. 차이점

- Interface

  - 유니온 타입 등의 복잡한 타입 확장 불가
  - 유니온 인터페이스라는 개념은 존재하지 않음
  - 보강(augment) 가능
    > **선언 병합**  
    >  같은 이름을 사용하는 두 인터페이스가 선언되었을 때 두 선언을 하나의 정의로 병합할 수 있음

- Type
  - 유니온이 될 수 있음
  - 매핑된 타입 또는 조건부 타입 등에 활용 가능

### 타입 연산과 제너릭 사용으로 반복 줄이기

**Don't Repeat Yourself**

- 중복된 타입 시그니처를 사용하는 함수 표현식을 타입 구문으로 작성하기
- 이미 존재하는 타입을 확장하는 경우, 확장할 수 없는 유니온 타입 등은 `&` 연산자를 통해 더 작은 범위의 타입을 _부분 집합으로_ 정의함으로써 확장 가능
- 그럼에도 반복되는 코드가 존재하면 **매핑된 타입** 사용
  - `Pick`, 배열에서 루프 도는 것과 같은 방식

**`extends`의 사용**

제너릭 매개변수가 특정 타입을 확장한다고 선언할 수 있음

### 동적 데이터에 인덱스 시그니처 사용

```ts
type Rocket = { [property: string]: string };
```

위처럼 작성하여 키의 이름에 대한 위치, 키의 타입, 값의 타입을 명시할 수 있음.

- 단점
  - 잘못된 키를 포함해 모든 키를 허용함
  - 키마다 다른 타입을 가질 수 없음
  - 자동 완성 기능 동작 불가
    → 이런 경우는 인터페이스를 사용

```ts
function parseCSV(input: string): {[colName: string]: string}[] { ... }
```

위의 예시는 CSV parsing하는 함수
일반적으로 열 이름(`colName`)이 무엇인지 알 수 있는 방법이 없다(런타임 때까지 객체의 속성을 알 수 없는 동적 데이터 etc)  
→ 이럴 땐 인덱스 시그니처 사용

- 런타임에 실제로 일치한다는 보장이 없다면 값 타입에 `undefined`를 추가해두고, 추후 체크를 추가하는 방법도 있음

**string 타입은 너무 광범위한데요**

- Record 사용하기 : 키 타입에 유연성을 제공하는 제너릭
- 매핑된 타입 사용하기 : 키마다 별도의 타입 사용

→ 그래도 웬만하면 정확한 타입을 사용하는 것이 좋음

### number 인덱스 시그니처보다 Array, Tuple, ArrayLike 사용하기

<key, value> 형태의 객체로 표현되는 JS

- 숫자는 키로 사용할 수 없음, JS 런타임은 이를 문자열로 변환

→ 타입스크립트는 숫자 키를 허용하고, 문자열 키와 다른 것으로 인식

- 인덱스 시그니처가 number로 표현되어 있어도 실제 런타임에 사용되는 키는 string임

**경우에 따라 for loop는**

- 인덱스에 신경쓰지 않는다: `for-of`
- 인덱스의 타입이 중요하다: `.forEach`
- 루프 중간에 멈춰야 한다: `for(;;)`

> for-in은 성능 면에서 좋지 않기도 하다.

### readonly

- 자바스크립트 배열은 내용을 변경할 수 있음

```js
> function arraySum(arr) {
...   var sum = 0,
...     num;
...   while ((num = arr.pop()) !== undefined) {
...     sum += num;
...   }
...   return sum;
... }
> function printTri(n) {
...   var nums = [];
...   for (var i = 0; i < n; i++) {
...     nums.push(i);
...     console.log(arraySum(nums));
...   }
... }

> printTri(5)
0
1
2
3
4
```

"계산이 끝나면 원래 배열이 전부 비게 됨"
`arraySum`에서 받고자 하는 `number[]`에 readonly 접근 제어자를 추가

→ 배열을 읽기만 할 수 있고, 배열을 변경하는 `pop`같은 메소드를 사용할 수 없음

> 여기서 `number[]`의 기능은 `readonly number[]`보다 기능이 많아서, 전자는 후자의 **서브타입**이 된다.

- 위와 같이 함수가 매개변수를 변경하지 않으면 `readonly`로 변경해야 함
- 어떤 함수가 `readonly`이면 그 함수를 호출하는 다른 함수도 `readonly`로 만들어야 함 → 타입 안전성 높임

### 매핑된 타입을 이용하여 값을 동기화하기

**어떤 UI 컴포넌트를 그린다고 가정했을 때**

- 실패에 닫힌 (보수적) 접근법: 정확하지만 너무 자주 그려질 수 있음
- 실패에 열린 접근법: 불필요하게 다시 그려지지는 않겠지만, 다시 그려야 할 때 누락 가능성 있음
  -> 모두 최적화에 이상적이지 않을 때
- 매핑된 타입과 객체를 사용하면 타입 체커가 동작하도록 수정 가능

- 인터페이스에 새로운 속성을 추가할 때 어떤 다른 인터페이스와 완전히 같은 속성을 가져야 할 때 매핑된 타입을 사용하면 좋음

타입과 같이 차이점이 존재함

# Summary

- 인덱스 시그니처는 동적 데이터를 다룰 때 사용하면 좋음
- 배열이 내용을 변경하는 것을 원하지 않으면 readonly 접근 제어자를 사용할 수 있음
- 매핑된 타입을 사용하는 것은 반복을 줄이는데도 용이하고, 같은 값을 가져야 하는 인터페이스에 속성을 추가하는데 사용하면 좋다.
