# Typescript study

> Week 4

## 3장 타입 추론

### 타입 추론?

수동으로 명시해야 하는 타입 구문의 수를 줄인다 -> 코드의 전체적인 안정성 향상
숙련자일수록 불필요한 타입 구문을 사용하지 않음

### 추론 가능한 타입 사용

타입스크립트는 타입을 위한 언어지만, **모든 변수 선언에 반드시 타입을 명시해야 하는 것은 아님**

- 단순한 타입 추론
  `let x: number = 12;` : 불필요한 타입 명시
  `let x = 12;` 로 작성해도 x는 number로 타입 추론이 일어남

- 복잡한 객체에서의 타입 추론

````ts
const person = {
    name: 'Someone\'s name',
    born: {
        where: 'Seoul, South Korea',
        when: 'Oct 31, 1889'
    },
    died: {
        where: 'Busan, South Korea',
        when: 'Dec 25, 1979'
    }
};
    ```
````

=> 객체 리터럴로 선언한 객체에서도 타입 추론이 일어남

- 타입스크립트가 추론한 리터럴 타입이 더 정확한 타입인 경우가 있음

### 비구조화 할당문

모든 지역 변수의 타입이 추론되게 함

### 이상적인 경우

함수와 메소드 시그니처 - 타입 구문이 있음
함수 내의 local var - 타입 구문이 없다

함수 매개변수에서 타입 구문을 생략하는 경우 -> number같이 굉장히 명시적인 타입 사용으로 충분히 추론 가능한 상황?

콜백 함수의 매개변수 타입은 자동으로 추론 \*라이브러리에 타입 정보가 있어서

### 객체 리터럴과 타입 구문

### 반환 타입은 명시해야 함

### 타입마다 변수 다르게 사용

변수는 바뀔 수 있지만 타입은 바뀔 수 없음

> 타입을 바꾸려면 "범위 좁히기" 사용

유니온 타입을 사용하면 타입을 바꿀 수는 있지만, 별도의 변수로 분리하는게 좋음(e.g. serial/id)

### 목적이 다른 변수 == 가려지는 변수

코드 작동에는 문제는 없지만 혼동을 막기 위해서 변수명을 다르게 사용하는 것이 좋다.

정적 분석 시점 == 컴파일 타임에 일어나는 과정

### 넓히기

더 넓은 범위의 타입을 추론

```ts
interface Vec3 {}

getComponent: axis를 리터럴만 들어오게 정의했지만,

let x = 'x';
-> 다른 것으로 바뀔 수 있고, 그러므로 리터럴이 아니라 string이다.

```

### 좁히기

- const 써서 좁히기
- 타입 단언(신중하게 사용해야 함)

```ts
const x = "x";
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x); // okay
```

- null 체크
- throw 예외

### 태그된 유니온, 구별된 유니온

0, '', => false

type AppEvent = UploadEvent | DownloadEvent

유니온을 type으로 지정한 것이 태그된 유니온
앱 이벤트 안에는 업로드이벤트와 다운로드이벤트가 있으니까,
e.type에 따라 추론이 될 것이다...

### 사용자정의 타입 가드

-> 타입 좁히기
함수를 사용해서 undefined 걸러내기

undefined가 아니면 제네릭으로 다른 타입이 들어가게 ...
