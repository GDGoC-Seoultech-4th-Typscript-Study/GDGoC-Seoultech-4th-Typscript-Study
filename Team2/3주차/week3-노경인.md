## 아이템 13. 타입과 인터페이스의 차이점 알기

명명된 타입 정의 2가지 → 일관된 사용이 필요함

1. 타입을 사용
2. 인터페이스 사용

비슷한 점

- 추가 속성을 할당한다면 오류가 발생
- 인덱스 시그니쳐 사용
- 함수 타입 정의 가능
- 제너릭이 가능
- 서로를 확장 가능 ( 인터페이스는 유니온 타입 같은 복잡한 타입을 확장할 수 없음) -> 복잡한 타입 확장은 타입과 &를 사용
- 클래스 구현시, 둘 다 사용 가능

차이점

- 유니온 타입은 존재, 유니온 인터페이스는 없음
- 타입은 유니온이 될 수도 있고, 매핑된 타입 or 조건부 타입 같은 기능으로 활용됨
- 타입은 튜플과 배열 타입도 더 간결하게 표현 가능, 인터페이스는 튜플과 같이 구현할 경우 concat과 같은 메서드 사용 불가 -> 튜플은 타입으로 구현이 좋음
- 인터페이스는 보강(augment)가 가능
선언 병합(declaration merging) : 여러 선언이 있을 경우 자동으로 병합해 하나의 선언으로 취급하는 기능

## 아이템 14. 타입 연산과 제너릭 사용으로 반복 줄이기

타입 중복은 코드 중복 만큼 많은 문제를 발생시킴.
타입 중복을 피하는 방법 : 타입에 이름을 붙여서 사용

- 시그니쳐를 명명된 타입으로 분리해 반복을 줄일 수 있음
- 인터페이스에서의 중복은 한 인터페이스가 다른 인터페이스를 확장해서 반복을 제거 가능

> 이미 존재하는 타입을 확장하는 경우, 인터섹션(&) 연산자를 사용 -> 유니온 타입(확장 불가능)에 속성을 추가할 경우에 유용
한 인터페이스의 일부분을 표현하는 인터페이스를 정의해야 되는 경우(부분 집합), 전체 집합을 인덱싱( ‘[ ]’)하여 속성의 타입에서 중복을 제거
> 
- 매핑된 타입을 사용하면 중복을 한 번 더 제거 가능 > 배열의 필드를 루프 도는 것과 같은 방식 (Pick 를 이용→ type Pick<T, K> = { [k in K]: T[k] };)

### 태그된 유니온(’|’)에서의 중복

- 유니온을 인덱싱 할 경우에 타입의 중복을 줄일 수 있음
- 유니온에 타입을 추가할 경우에 자동적으로 인덱싱 한 값도 추가가 됨

: 생성하고 난 뒤 업데이트가 되는 클래스를 정의하는 경우 → update를 하는 메서드는 생성자(constructor)와 동일한 매개변수 + 대부분의 타입이 선택적 필드가 됨.(매개변수 ?: 타입) 

keyof를 사용해서 update 메서드의 타입을 정의하는 인터페이스에서 반복을 제거 가능.

### 값의 형태에 해당하는 타입을 정의할 경우

*‘typeof’* 를 사용하여 타입 정의

제너릭 타입은 타입을 위한 함수의 역할
제너릭 타입에서 매개변수를 제한하는 방법 : extends를 사용

## **아이템15. 동적 데이터에 인덱스 시그니처 사용하기**

자바스크립트 객체는 문자열 키를 타입의 값에 관계없이 매핑하지만 타입스크립트에서는 타입에 ‘인덱스 시그니처’를 명시하여 유연하게 매핑을 표현 가능

**인덱스 시그니쳐**

- 키의 이름 : 키의 위치만 표시 용도
- 키의 타입 : string, number or symbol의 조합이어야 하지만 대부분 string
- 값의 타입 : 어느 것이든 가능

단점

1. 잘못된 키를 포함해 모든 키 허용
2. 특정 키가 필요X, {}도 유효하게 됨
3. 키마다 다른 타입을 가질 수 없음
4. 키는 무엇이든 가능하기 때문에 자동완성 동작X

인터페이스를 통해 타입을 정의하는게 타입스크립트에서 제공하는 언어 서비스를 이용에 좋음

인덱스 시그니쳐는 동적 데이터 표현할 때 사용함.
런타임 때까지 객체의 속성을 알 수 없을 경우에 인덱스 시그니처를 사용
안전한 접근을 위해 인덱스 시그니처 값 타입에 undefined 추가하는 게 좋음

## 아이템 16. number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

객체(in javascript) : 키/값 쌍의 모음

- 주로 ‘키(key)’는 문자열, ‘값(value)’은 어떤 것이든 가능
- 숫자는 키로 사용할 수 없음

‘배열’ 의 경우 **객체**이기 때문에, 숫자 인덱스를 사용 + 문자열이 변환 가능하기 때문에 문자열로 숫자를 표현해 인덱스로 사용할 경우, 문자열로 배열 요소에 접근이 가능

→ 이런 점을 바로 잡기 위해, 타입스크립트에서는 숫자 키를 허용하고, 문자열 키와는 다른 것으로 인식

배열을 순회하는 방법
xs = [1,2,3]

1. for (const key in xs) →  const x = xs[key] 동작은 하지만 코드 스타일에 대한 실용적인 허용임.
2. 인덱스에 신경 쓰지 않는 경우 : for-of 사용
3. 인덱스의 타입이 중요한 경우, number 타입을 제공해줄 Array.prototype.forEach 사용
xs.forEach((x,i))
4. 루프 중간에 멈춰야 할 경우, for loop 사용

인덱스 시그니처가 number로 표현되어 있다면 입력한 값이 number여야됨.

하지만, 실제로 런타임에서 사용되는 키는 ‘*string*’이다. 

따라서 인덱스 시그니처로 *number*를 사용할 이유는 많지 않음. 만일 숫자를 사용하여 인덱스 할 항목을 지정한다면 Array or 튜플 타입을 사용.

> 길이를 가지는 배열과 비슷한 형태의 튜플을 사용하고 싶다면 ArrayLike 타입을 사용 → arraylike는 여전히 키가 ‘문자열’임
> 

## 아이템 17. 변경 관련된 오류 방지를 위해 readonly 사용하기

*‘readonly number[]*’와 *‘number[]’*의 차이

- 배열의 요소 읽기만 가능(쓰기x)
- length를 읽을 수 있지만, 바꾸기 불가능(pop, push, shift 등 메서드 불가)
- number[]는 readonly number[]의 **서브타입**이 됨.
    - 변경 가능한 배열을 readonly 배열에 할당은 가능하지만 반대는 불가능
        - Readonly number[] = number[]는 불가능, 반대는 가능

readonly를 선언한 경우,

- 타입스크립트는 매개변수가 함수 내에서 변경이 일어나는지 체크
- 함수가 매개변수를 변경하지 않는다는 보장을 받음
- 호출하는 쪽에서 함수에 readonly 배열을 매개변수로 넣을 수 있음

예시에서 나온 function의 매개변수로 readonly number[]를 넣어야 함수가 정상적으로 작동

push 메서드는 원본을 수정하지만, concat은 원본을 수정하지 않고 새 배열을 반환함. + 선언부를 const가 아닌 let으로 바꿔야 새 배열을 반환할 수 있음(한쪽의 변경 가능성을 옮김). -> 해당 변수가 가리키는 배열을 바꿀 수 있지만 그 배열 자체는 변경하지 못하도록 할 수 있음
: 리액트에서는 상태가 변경될 때마다 컴포넌트가 다시 렌더링 될 필요가 있는지 결정을 하는데, 만약 원본 배열을 직접 수정할 경우, 배열의 참조는 그대로 유지되기 때문에, 배열의 내용이 바뀐 것을 감지하지 못하고 렌더링을 생략할 수 있음.

- const와 readonly의 차이
const : 변수의 재할당을 금지, 객체나 배열의 내부 값은 수정 가능
readonly : 객체 속성이나 배열의 요소 변경을 금지하여 내부 값이 변경되지 않도록 보장

## 아이템 18.  매핑된 타입을 사용하여 값을 동기화하기

[k in keyof ScatterProps] 

→ ScatterProps 인터페이스에 있는 키 값들을 매핑하는 역할

매핑된 타입은 객체 내의 같은 속성을 가지게 할 경우에 사용하는 게 좋음.
→ 매핑하려는 인터페이스에 새로운 속성이 추가되었지만, 매핑된 타입을 적용하려는 객체에 해당 속성을 모두 가지지 않은 경우엔 오류가 발생.
