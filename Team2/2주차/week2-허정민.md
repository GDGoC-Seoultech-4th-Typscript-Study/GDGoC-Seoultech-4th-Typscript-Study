# typrscript 2주차

---

> **편집기를 사용하여 타입 시스템 탐색하기**
> 

타입스크립트를 설치하면 두 가지를 실행할 수 있다.

1. 타입스크립트 컴파일러(tsc)

2. 타입스크립트 서버(tsserver)

보통은 타입스크립트 컴파일러를 실행하는 것이 주된 목적이지만, 타입스크립트 서버 또한 `언어 서비스`를 제공한다는 점에서 중요하다.

보통의 경우, 심벌 위에 마우스 커서를 대면 타입스크립트가 그 타입을 어떻게 판단하고 있는지 확인할 수 있다.

예를 들어 num 이라는 변수에 숫자를 할당하면 타입스크립트는 값을 보고 그 타입을 알아낸다.

이 부분은 함수에도 가능하다.
타입스크립트는 함수의 반환 값을 보고 타입을 추론한다.
이 타입이 기대한 것과 다르다면 타입 선언을 직접 명시하고, 실제 문제가 발생하는 부분을 찾아 봐야 한다.

---

> **타입이 값들의 집합이라고 생각하기**
> 

- 타입의 집합 유형

가장 작은 집합은 아무 값도 포함하지 않는 공집합이며 타입스크립트에서는 never 타입이다.

never 타입으로 선언된 변수의 범위는 공집합이기 때문에 아무런 값도 할당할 수 없다.

리터럴 타입은 유닛 타입이라고도 불리며 한 가지 값만을 포함하는 타입이다.

```tsx
type A = 'A';
```

두개 혹은 세개로 묶으려면 유니온(union) 타입을 사용한다.

```tsx
type AB = 'A' | 'B'
```

- 타입 연산

&연산자는 두 타입의 인터섹션(intersection: 교집합)을 계산한다

타입 연산자는 인터페이스의 속성이 아닌, 값의 집합(타입의 범위)에 적용된다.

|(or) 연산자는 2개의 타입 중 하나만 만족시켜도 된다.

---

> **타입 공간과 값 공간의 심벌 구분하기**
> 

심벌은 이름이 같더라도 타입 또는 값을 나타낼 수 있으며 서로 관련이 없다

- class, enum

상황에 따라 타입과 값 두 가지 모두 가능한 예약어

- “foo”

문자열 리터럴이거나 문자열 리터럴 타입일 수 있습니다.

- typeof 연산자

타입에서 쓰일 때와 값에서 쓰일 때 다른 기능을 한다.

타입의 관점에서,  typeof는 값을 읽어서 타입스크립트 타입을 반환합니다

값의 관점에서, typeof는 자바스크립트 런타임의 typeof 연산자가 됩니다. 자바스크립트에는 string, number, boolean, function, object, undefined 의 런타임 타입만 존재합니다

---

> **타입 단언보다는 타입 선언을 사용하기**
> 

타입 선언 (Declaration) : 일반적인 방법 

타입 단언 (Assertion) : as 키워드를 사용하여 타입을 강제로 지정하고, 타입 체커에게 오류를 무시하게 함

예시

```tsx
interface Person {
    name: string
}

const alice: Person = { name: "Alice" }; // 타입 선언
const bob = { name: "Bob" } as Person; // 타입 단언
```

타입 선언을 사용하는 것이 좋습니다. 왜냐하면 타입 단언은 타입 체크를 무력화합니다

타입 단언이 꼭 필요할 때

DOM element에 접근할 때는 타입 단언이 필요하다

타입스크립트가 DOM에 접근할 수 없기 때문에 DOM element가 없을 수도 있다고 여겨버린다

따라서 DOM에 접근할 때는, ! 또는 as를 통해 엘리먼트가 null 타입이 아님을 단언해야 한다

---

> **객체 래퍼 타입 피하기**
> 

문자열, 숫자, 불리언 값에 대하여 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라고 한다

타입스크립트의 기본형과 객체 래퍼 타입

- string, String (특히 유의)
- number, Number
- boolean, Boolean
- symbol, Symbol
- bigint, BigInt

기본형 타입을 사용해야 한다.

---

> **잉여 속성 체크의 한계 인지하기**
> 

잉여 속성 체크는 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 발생하는 타입스크립트의 특별한 검사 과정입니다.

이 검사는 객체 타입에 지정된 속성 외에 다른 속성이 있는지 확인합니다. 만약 추가 속성이 있다면 오류를 발생시킵니다.

하지만 잉여 속성 체크에는 한계가 있습니다:

- 임시 변수를 사용하면 잉여 속성 체크를 우회할 수 있습니다.
- 인덱스 시그니처를 사용하는 타입에는 잉여 속성 체크가 적용되지 않습니다.
- 타입 단언(as)을 사용하면 잉여 속성 체크를 피할 수 있습니다.

이러한 한계를 인지하고 사용해야 타입 안정성을 보장할 수 있습니다. 특히 객체를 정의할 때는 가능한 한 정확하게 타입을 지정하고, 필요한 경우에만 예외적으로 이러한 방법들을 사용해야 합니다.

---

> **함수 표현식에 타입 적용하기**
> 

함수의 문장 표현

```tsx
function rollDice1(sides: number): number { /* ... */ }
```

함수 표현식

```tsx
const rollDice2 = function(sides: number): number { /* ... */ }
const rollDice3 = (sides: number) : number => { /* ... */ }
```

함수 표현식을 사용할 때의 장점은 전체 함수 타입을 지정할 수 있다는 것입니다. 이를 통해 매개변수와 반환 값의 타입을 한 번에 정의할 수 있어 코드의 가독성과 재사용성이 향상됩니다.  따라서 타입스크립트에서는 함수 표현식을 사용하는게 좋다.

```
/함수 선언문으로 만든 아래 4개의 함수
function add(a: number, b: number): number {
    return a + b;
}
function sub(a: number, b: number): number {
    return a - b;
}
function mul(a: number, b: number): number {
    return a * b;
}
function div(a: number, b: number): number {
    return a / b;
}
//함수 표현식으로 줄인 코드
type BinaryFn = (a: number, b: number) => number;
const add: BinaryFn = (a, b) => a + b;
const sub: BinaryFn = (a, b) => a - b;
const mul: BinaryFn = (a, b) => a * b;
const div: BinaryFn = (a, b) => a / b;
```

같은 타입 시그니처를 반복적으로 작성한 코드는 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾는 것이 좋다.