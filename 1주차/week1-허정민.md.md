# typescript 1주차

---

> **타입스크립트는 자바스크립트의 상위집합이다.**
> 

.ts 뿐만아니라 .js 파일에 있는 코드도 타입스크립트다. 이는 자바스크립트 코드를 타입스크립트로 옮길 수 있음을 뜻한다.

> **타입스크립트는 런타임 오류를 발생시키는 코드를 찾아내려 한다.**
> 

- 타입스크립트는 초기 값으로부터 타입을 추론
- 타입 구문을 추가하면 훨씬 더 많은 오류 찾을 수 있음 (코드의 의도 알려주기)
- 프로그램에 오류가 발생하지 않더라도 타입 체커가 오류를 표시할 수 있음
- 모든 오류를 찾을 순 없음

---

> **타입스크립트 설정**
> 

설정 파일 tsc —init  **→** 타입스크립트의 의도를 동료나 다른 도구가 알 수 있음

<aside>
📌

***noImplicitAny***

변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어하는 설정이다.

</aside>

<aside>
📌

***strictNullchecks***

null과 undefined가 모든 타입에서 허용되는지 확인하는 설정이다.

</aside>

좋은 타입스크립트 코드를 작성하고 싶다면 위의 두 설정 모두 true로 사용

noImplicitAny를 true로 설정하면 타입 체크 기능을 활용해 용이하고 가독성이 좋아진다

strictNullChecks를 true로 설정하면 코드 작성이 어려워질 수 있지만 null과 undefined 관련 오류를 미리 방지할 수 있어 런타임 에러를 줄일 수 있다. 

---

> **코드 생성과 타입은 관계 없다**
> 

컴파일은 타입 체크와 독립적이기 때문에 타입 오류가 있어도 컴파일이 가능하다

런타임에는 타입 체크가 불가능하다. 타입스크립트의 타입은 컴파일 타임에만 존재하며, 자바스크립트로 컴파일된 후에는 모든 타입 정보가 제거된다.

이는 타입스크립트가 정적 타입 검사를 수행하는 언어이기 때문이다. 런타임에 타입을 체크하려면 별도의 로직을 구현해야 한다.

런타임 타입은 선언된 타입과 다를 수 있다. 타입 선언은 모두 삭제되어 API를 잘못 파악하거나 의도와 다른 타입으로 에러가 발생할 수 있다.

타입스크립트의 타입으로 함수를 오버로드할 수 없다. 함수 오버로딩은 같은 이름의 함수를 여러 개 정의하는 것인데, 타입스크립트에서는 이를 타입 수준에서만 할 수 있다.

예를 들어, 다음과 같은 코드는 타입스크립트에서 유효하지만 실제 런타임에서는 마지막으로 정의된 함수만 존재한다:

```tsx
function greet(name: string): string;
function greet(name: string, age: number): string;
function greet(name: string, age?: number): string {
    if (age !== undefined) {
        return `Hello, ${name}! You are ${age} years old.`;
    }
    return `Hello, ${name}!`;
}
```

이 코드에서 첫 두 줄은 타입 정의일 뿐이며, 실제 구현은 마지막 함수에서 이루어진다. 런타임에는 오직 마지막 함수만 존재하게 된다.

---

> **구조적 타이핑에 익숙해지기**
> 

구조적 타이핑은 타입스크립트의 핵심 개념 중 하나로, 객체의 구조에 기반하여 타입을 검사하는 방식을 말한다.

이 시스템에서는 객체가 필요한 속성과 메서드를 가지고 있다면, 그 객체는 해당 타입으로 간주된다. 이는 명목적 타이핑(nominal typing)과는 대조적이다.

예를 들어:

```tsx
interface Point {
  x: number;
  y: number;
}

function printPoint(p: Point) {
  console.log(`${p.x}, ${p.y}`);
}

const point = { x: 10, y: 20 };
printPoint(point); // 정상 작동
```

여기서 `point` 객체는 `Point` 인터페이스를 명시적으로 구현하지 않았지만, 필요한 속성을 모두 가지고 있기 때문에 `Point` 타입으로 취급된다.

구조적 타이핑은 때때로 예상치 못한 오류를 발생시킬 수 있다. 

---

> **any 타입 지양하기**
> 

- any 타입에는 타입 안전성이 없다
- any는 함수 시그니처를 무시한다
- 언어 서비스가 적용되지 않는다
- 코드 리팩터링 때 버그를 감춘다
- 타입 설계를 감춘다
- 타입시스템의 신뢰도를 떨어뜨린다